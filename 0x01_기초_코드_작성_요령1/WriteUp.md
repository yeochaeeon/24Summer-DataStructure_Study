# 0x01_기초 코드 작성 요령 1
## 1. Time,Space Complexity
### 시간 복잡도 ( Time Complexity )

- 컴퓨터가 1초에 처리할 수 있는 연산의 수 : 대략 3억 ~ 5억개 
- 그렇다면, **1초라는 시간제한** 안에 프로그램의 모든 연산을 수행하고 정상적으로 종료시키기 위해서는 3억개 - 5억개의 연산으로 프로그램을 짜야한다.
- 다음 함수가 실행 될 때 몇 번의 연산이 필요한지 짐작해보자.

```c
int func1(int arr[], int n){
    int cnt = 0; 
    for(int i = 0; i < n ; i++){
        if(arr[i] % 5 == 0) cnt++; 
    }
    return cnt;
}
```
```
1. cnt 변수 선언 -> 0대입 : 1번 
2. i 변수에 0 대입 : 1번 
3. i가 n보다 작은지 확인 후 , 작으면 1증가 : 2번
4. 5로 나눈 나머지 계산 후 그 결과가 0과 일치하는지 확인 : 2번 
5. 0과 일치하면 cnt에 1을 더함 : 1번 
6. cnt 반환 : 1번 
```
- 3부터 5까지의 과정은 반복문을 통해 n번 실행되기에 총 연산의 수를 계산하면 `5n+3`임을 알 수 있다.
- n이 100만 정도라면 총 `5n+3`이라는 식에 따라 대략 500만 번의 연산이 필요하기에 위 함수는 1초안에 충분히 돌 수 있을 것이다.

> **시간복잡도**의 정의 : 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계

### Big-O Notation

- 빅오표기법은 값이 가장 큰 대표항만 남겨서 나타내는 방식을 뜻한다.
- 시간복잡도를 표기할 때 빅오표기법으로 나타낸다.
- 앞에서 계산한 `5n+3`은 빅오표기법에 따라 상수를 버리고, 최고차항의 계수도 버려 `O(N)`으로 나타낼 수 있다.
- `2N+10lgN`의 경우 N의 값이 커질수록  10lgN보다는 2N이 훨씬 클테니 로그항은 버리고 `2N`만 남긴 후 앞의 계수도 떼서 `O(N)`으로 나타낼 수 있다.
- `NlgN + 30N + 10`은 N보다 NlogN이 더 크기 때문에 `O(NlgN)`로 나타낼 수 있다.

### N의 크기와 그에 따른 허용 시간복잡도

| N의 크기          | 허용 시간복잡도       |
|-------------------|------------------------|
| N ≤ 11            | O(N!)                  |
| N ≤ 25            | O(2^N)                 |
| N ≤ 100           | O(N^4)                 |
| N ≤ 500           | O(N^3)                 |
| N ≤ 3,000         | O(N^2 lg N)            |
| N ≤ 5,000         | O(N^2)                 |
| N ≤ 1,000,000     | O(N lg N)              |
| N ≤ 10,000,000    | O(N)                   |
| 그 이상           | O(lg N), O(1)          |

- 만약 어떤 프로그램의 시간복잡도가 `O(N!)`라면 위 표에 따라 N이 11이하 정도로 작지 않은 한, 시간제한을 통과하기 힘들 것이다.
- 따라서 문제를 풀기 전에 `N의 값`,내 풀이의 `시간복잡도`를 확인하고 제한 시간내에 프로그램이 실행 될 수 있는지 생각한 후 구현을 시작하는 것이 좋다.

### Space Complexity ( 공간 복잡도 )

> 공간복잡도: 입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계

**메모리(공간) 제한이 512MB라면, 1.2억개의 int(입력의 크기)를 선언할 수 있다.**



## 2. 정수 자료형 
### 각 정수 자료형의 표현 범위
| 자료형      | 크기     | 값의 표현범위                                           | ` |
|-------------|----------|----------------------------------------------------------|-----------|
| char        | 1byte  | -128 ~ +127                                              | (-2^7) ~ (2^7-1)       |
| short       | 2byte  | -32,768 ~ +32,767                                        | (-2^15) ~ (2^15-1)      |
| int         | 4byte  | -2,147,483,648 ~ +2,147,483,647                          | (-2^31) ~ (2^31-1)      |
| long        | 4byte  | -2,147,483,648 ~ +2,147,483,647                          | (-2^31) ~ (2^31-1)      |
| long long   | 8byte  | -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,807  | (-2^63) ~ (2^63-1)      |

### Integer Overflow 
```cpp
void func1(){
    for( char s = 0; s < 128; s++){
        std::cout << "hi" ;
    }
}
```
- char 자료형의 표현범위는 -128 ~ 127이다. s가 127인 상태에서 for문을 돌면 s에 1이 더해진다.
- 이 때 프로그래머가 의도한대로 s가 128이 되지 않고 **integer overflow**가 발생해 -1이 되어 이 함수는 무한루프를 돌게 된다.
- 따라서 자료형을 char에서 int로 바꾸어주면 정상적인 작동을 한다.
---
```cpp
int func3() {
    int a = 1;
    int mod = 1000000007;
    for(int i = 0; i <10 ; i++) {
        a = 10 * a % mod;
    }
    return a;
}
```
- 이 코드에서도 동일하게 a가 10의 9승일 때 10이 곱해지는 순간 int의 최대 범위를 넘어서는 **integer overflow**가 발생한다.

## 3. 실수 자료형 
### 컴퓨터가 실수를 저장하는 법
- `ex1`
3.75 == 2+1+0.5+0.25 == 2^1+2^0+2^-1+2^-2 == 3.75는 2진수로 11.11
- `ex2`
1/3 == 2^-2+2^-4+2^-6+⋯ == 이진수로 0.010101⋯
### IEEE-754 format 실수자료형의 성질
- IEEE-754
![ieee](../imgs/ieee.png)
    - `float`자료형의 각 필드의 크기 : sign(1bit) , exponent(11bit) , fraction(23bit)
    - `double`자료형의 각 필드의 크기 : sign(1bit) , exponent(11bit) , fraction(52bit)

> **1. 실수의 저장/연산 과정에서 반드시 오차가 발생할 수 밖에 없다.**
- 위 ieee format에 따라 fraction field가 유한하기 때문에 2진수 기준으로 무한소수를 저장할 때 `float`은 상위 23bit, `double`은 상위 52bit까지만 잘라서 저장할 수 밖에 없기에 오차가 발생한다.

- `float` 의 유효숫자 : 6자리 -> 상대오차 10^-6까지 안전
- `double`의 유효숫자 : 15자리 -> 상대오차 10^-15까지 안전 

- 실수자료형이 필요할때는 메모리 공간 문제가 없는 한 상대오차 허용범위가 큰 `double`을 사용할 것.

> **2. double에 long long범위의 정수를 함부로 담으면 안된다.**
```c
int main (void){
    double a = 1000000000000000001; // 10의 18승 + 1
    double b = 1000000000000000000; // 10의 18승 
    if (a == b) std::cout << "equal";
    else std::cout << "not equal";
    // result : equal 
}
```
- `double`에 `longlong`범위의 정수를 담을 경우 유효숫자를 담는 공간의 크기가 `longlong`보다 작기에 `double`의 유효숫자 범위를 넘는 차이에 대해서는 구분할 수 없다. ( 10의 18승과 10의 18승 + 1 을 대입했지만 같은 값으로 저장됨. )

> **3. 실수 비교시 등호를 사용하면 안된다.**
```c
int main (void){
    double a = 0.1+0.1+0.1;
    double b = 0.3;

    if (a==b) std::cout <<"same 1" ;
    if (abs(a-b) < 1e-12) std::cout << "same 2" ;

    // result : same2
}

```
- 실수끼리 같은지 비교를 할 때에는 ***위 코드와 같이 등호를 사용하는 방법이 아닌*** 둘의 차이가 아주 작은 값, ***대략 (10^-12)이하면 같다고 처리하는 방식***을 사용한다.
